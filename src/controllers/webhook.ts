import { Request, Response } from 'express';
import mongoose from 'mongoose';
import crypto from 'crypto';
import Account from '../models/account.model';
import { AccountTransaction } from '../models/transaction.model';
import { FLW_SECRET_KEY } from '../config/env.config';

/* -------------------- Signature Verification -------------------- */
const verifyFlutterwaveSignature = (req: Request) => {
  const signature = req.headers['verif-hash'] as string;

  const hash = crypto
    .createHmac('sha256', FLW_SECRET_KEY!)
    .update(JSON.stringify(req.body))
    .digest('hex');

  return signature === hash;
};

/* -------------------- Unified Webhook -------------------- */
export const flutterwaveWebhook = async (req: Request, res: Response) => {
  if (!verifyFlutterwaveSignature(req)) {
    return res
      .status(400)
      .json({ success: false, message: 'Invalid signature' });
  }

  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const payload = req.body.data;
    const status = payload.status;

    /**
     * CREDIT (Card / Bank Deposit)
     * tx_ref is generated by you on payment initialization
     */
    if (payload.tx_ref) {
      const reference = payload.tx_ref;
      const userId = payload.customer?.id;
      const amount = payload.amount;

      if (status !== 'successful') {
        return res
          .status(200)
          .json({ success: true, message: 'Credit not successful, ignored' });
      }

      // Idempotency: prevent double credit
      const exists = await AccountTransaction.exists({ reference });
      if (exists) {
        return res
          .status(200)
          .json({ success: true, message: 'Credit already processed' });
      }

      const account = await Account.findOne({ userId }).session(session);
      if (!account) throw new Error('Account not found');

      await Account.updateOne(
        { _id: account._id },
        { $inc: { balance: amount } },
        { session }
      );

      await AccountTransaction.create(
        [
          {
            userId,
            accountId: account._id,
            type: 'credit',
            source: 'deposit',
            amount,
            currency: payload.currency,
            status: 'successful',
            reference,
            meta: {
              paymentType: payload.payment_type,
              flutterwaveCreatedAt: payload.created_at,
              flwTransactionId: payload.id,
            },
          },
        ],
        { session }
      );

      await session.commitTransaction();

      return res
        .status(200)
        .json({ success: true, message: 'Account credited successfully' });
    }

    /**
     * DEBIT (Withdrawal / Transfer)
     * reference is your internal transaction reference
     */
    if (payload.reference) {
      const reference = payload.reference;

      const transaction = await AccountTransaction.findOne({
        reference,
        type: 'debit',
      }).session(session);

      if (!transaction) {
        return res
          .status(200)
          .json({ success: true, message: 'Debit transaction not found' });
      }

      // Idempotency guard
      if (['successful', 'failed'].includes(transaction.status)) {
        return res
          .status(200)
          .json({ success: true, message: 'Debit already finalized' });
      }

      if (status === 'SUCCESSFUL') {
        transaction.status = 'successful';
        transaction.meta = {
          ...transaction.meta,
          flwTransferId: payload.id,
          completedAt: new Date(payload.created_at),
        };
      } else {
        transaction.status = 'failed';
        transaction.meta = {
          ...transaction.meta,
          flwTransferId: payload.id,
          failureReason:
            payload.complete_message || 'Transfer failed',
        };
      }

      await transaction.save({ session });
      await session.commitTransaction();

      return res
        .status(200)
        .json({ success: true, message: 'Debit transaction updated' });
    }

    /* -------------------- Unknown Event -------------------- */
    return res
      .status(200)
      .json({ success: true, message: 'Unhandled event type' });

  } catch (error: any) {
    await session.abortTransaction();
    return res
      .status(500)
      .json({ success: false, message: error.message });
  } finally {
    session.endSession();
  }
};
